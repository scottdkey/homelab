use anyhow::{Context, Result};
use rusqlite::Connection;
use std::collections::HashMap;

// Include auto-generated migration declarations
// Generated by: halvor generate migrations
// The generated.rs file must exist - run 'halvor generate migrations' to create/update it
include!("generated.rs");

/// Migration function types
type MigrationUpFn = fn(&Connection) -> Result<()>;
type MigrationDownFn = fn(&Connection) -> Result<()>;

/// Migration definition
struct Migration {
    version: u32,
    name: &'static str,
    up: MigrationUpFn,
    down: Option<MigrationDownFn>,
}

/// Get the highest migration version that has been applied
pub fn get_current_migration_version(conn: &Connection) -> Result<u32> {
    // Check if migrations table exists
    let table_exists: bool = match conn.query_row(
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='migrations'",
        [],
        |row| {
            let count: i32 = row.get(0)?;
            Ok(count > 0)
        },
    ) {
        Ok(exists) => exists,
        Err(_) => false,
    };

    if !table_exists {
        return Ok(0);
    }

    let mut stmt = conn
        .prepare("SELECT MAX(version) FROM migrations")
        .context("Failed to prepare migration version query")?;
    let mut rows = stmt
        .query_map([], |row| {
            let version: Option<u32> = row.get(0)?;
            Ok(version)
        })
        .context("Failed to query migration versions")?;

    if let Some(row) = rows.next() {
        Ok(row?.unwrap_or(0))
    } else {
        Ok(0)
    }
}

/// Get the list of applied migrations
pub fn get_applied_migrations(conn: &Connection) -> Result<HashMap<u32, String>> {
    let table_exists: bool = match conn.query_row(
        "SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='migrations'",
        [],
        |row| {
            let count: i32 = row.get(0)?;
            Ok(count > 0)
        },
    ) {
        Ok(exists) => exists,
        Err(_) => false,
    };

    if !table_exists {
        return Ok(HashMap::new());
    }

    let mut stmt = conn
        .prepare("SELECT version, name FROM migrations ORDER BY version")
        .context("Failed to prepare applied migrations query")?;
    let rows = stmt
        .query_map([], |row| {
            let version: u32 = row.get(0)?;
            let name: String = row.get(1)?;
            Ok((version, name))
        })
        .context("Failed to query applied migrations")?;

    let mut applied = HashMap::new();
    for row in rows {
        let (version, name) = row?;
        applied.insert(version, name);
    }

    Ok(applied)
}

/// Record that a migration has been applied
fn record_migration(conn: &Connection, version: u32, name: &str) -> Result<()> {
    let now = chrono::Utc::now().timestamp();
    conn.execute(
        "INSERT INTO migrations (version, name, applied_at) VALUES (?1, ?2, ?3)",
        rusqlite::params![version, name, now],
    )
    .context("Failed to record migration")?;
    Ok(())
}

/// Remove a migration record (for rollback)
fn remove_migration_record(conn: &Connection, version: u32) -> Result<()> {
    conn.execute(
        "DELETE FROM migrations WHERE version = ?1",
        rusqlite::params![version],
    )
    .context("Failed to remove migration record")?;
    Ok(())
}

/// Run all pending migrations
///
/// This function automatically runs any migrations that haven't been applied yet,
/// in sequential order based on their version number.
pub fn run_migrations(conn: &Connection) -> Result<()> {
    let current_version = get_current_migration_version(conn)?;

    for migration in MIGRATIONS {
        if migration.version > current_version {
            println!(
                "Running migration {}: {}",
                migration.version, migration.name
            );
            (migration.up)(conn).with_context(|| {
                format!(
                    "Failed to run migration {}: {}",
                    migration.version, migration.name
                )
            })?;
            record_migration(conn, migration.version, migration.name)?;
        }
    }

    Ok(())
}

/// Run the next pending migration (migrate up one)
pub fn migrate_up(conn: &Connection) -> Result<()> {
    let current_version = get_current_migration_version(conn)?;

    for migration in MIGRATIONS {
        if migration.version > current_version {
            println!(
                "Running migration {}: {}",
                migration.version, migration.name
            );
            (migration.up)(conn).with_context(|| {
                format!(
                    "Failed to run migration {}: {}",
                    migration.version, migration.name
                )
            })?;
            record_migration(conn, migration.version, migration.name)?;
            return Ok(());
        }
    }

    println!("No pending migrations to run");
    Ok(())
}

/// Rollback the last applied migration (migrate down one)
pub fn migrate_down(conn: &Connection) -> Result<()> {
    let current_version = get_current_migration_version(conn)?;

    if current_version == 0 {
        println!("No migrations to rollback");
        return Ok(());
    }

    // Find the migration to rollback
    for migration in MIGRATIONS.iter().rev() {
        if migration.version == current_version {
            if let Some(down_fn) = migration.down {
                println!(
                    "Rolling back migration {}: {}",
                    migration.version, migration.name
                );
                down_fn(conn).with_context(|| {
                    format!(
                        "Failed to rollback migration {}: {}",
                        migration.version, migration.name
                    )
                })?;
                remove_migration_record(conn, migration.version)?;
                println!("âœ“ Successfully rolled back migration {}", migration.version);
            } else {
                anyhow::bail!(
                    "Migration {} ({}) does not support rollback",
                    migration.version,
                    migration.name
                );
            }
            return Ok(());
        }
    }

    anyhow::bail!("Migration version {} not found", current_version);
}

/// Get the list of all available migrations
pub fn list_migrations() -> Vec<(u32, &'static str, bool)> {
    MIGRATIONS
        .iter()
        .map(|m| (m.version, m.name, m.down.is_some()))
        .collect()
}

/// Get migration status (applied vs available)
pub fn get_migration_status(conn: &Connection) -> Result<Vec<(u32, String, bool, bool)>> {
    let applied = get_applied_migrations(conn)?;
    let mut status = Vec::new();

    for migration in MIGRATIONS {
        let is_applied = applied.contains_key(&migration.version);
        let can_rollback = migration.down.is_some();
        status.push((
            migration.version,
            migration.name.to_string(),
            is_applied,
            can_rollback,
        ));
    }

    Ok(status)
}
