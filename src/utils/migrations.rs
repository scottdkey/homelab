// Migration generation utilities
// This module contains functions to generate migration declarations from migration files

use anyhow::{Context, Result};
use std::env;
use std::fs;
use std::path::Path;
use std::path::PathBuf;

/// Generate migrations (for use in build.rs or CLI)
pub fn generate_migrations() {
    if let Err(e) = generate_migrations_cli() {
        eprintln!("Warning: Failed to generate migrations: {}", e);
    }
}

/// Generate migrations (CLI version with proper error handling)
pub fn generate_migrations_cli() -> Result<()> {
    let migrations_dir = Path::new("src/db/migrations");
    if !migrations_dir.exists() {
        return Ok(());
    }

    let mut migrations = Vec::new();

    // Scan for migration files
    if let Ok(entries) = fs::read_dir(migrations_dir) {
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    // Skip mod.rs
                    if file_name == "mod.rs" {
                        continue;
                    }

                    // Check if it's a migration file (format: NNN_name.rs)
                    if file_name.ends_with(".rs") {
                        let name_without_ext = file_name.trim_end_matches(".rs");
                        let parts: Vec<&str> = name_without_ext.split('_').collect();

                        if let Some(version_str) = parts.first() {
                            if let Ok(version) = version_str.parse::<u32>() {
                                let name = parts[1..].join("_");
                                let mod_name = format!("migration_{:03}_{}", version, name);

                                migrations.push((version, name, mod_name, file_name.to_string()));
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort by version
    migrations.sort_by_key(|m| m.0);

    // Generate mod declarations
    let mut mod_declarations = String::new();
    let mut migrations_array = String::new();

    for (version, name, mod_name, file_name) in &migrations {
        mod_declarations.push_str(&format!(
            "mod {} {{\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/db/migrations/{}\"));\n}}\n",
            mod_name, file_name
        ));

        // Check if this is the initial schema (version 1, name "initial_schema")
        let has_down = version != &1 || name != "initial_schema";

        migrations_array.push_str(&format!(
            "    Migration {{\n        version: {},\n        name: \"{}\",\n        up: {}::up,\n        down: {},\n    }},\n",
            version,
            name,
            mod_name,
            if has_down {
                format!("Some({}::down)", mod_name)
            } else {
                "None".to_string()
            }
        ));
    }

    // Write to a file that can be included
    let output = format!(
        r#"// Auto-generated migration declarations
// This file is generated by build.rs - do not edit manually

{}

const MIGRATIONS: &[Migration] = &[
{}
];
"#,
        mod_declarations, migrations_array
    );

    // Write to OUT_DIR if available (build.rs context), otherwise to src/db/migrations/generated.rs
    let output_path = if let Ok(out_dir) = env::var("OUT_DIR") {
        PathBuf::from(out_dir).join("migrations_gen.rs")
    } else {
        // CLI context - write to a location that can be included
        PathBuf::from("src/db/migrations").join("generated.rs")
    };

    fs::write(&output_path, output)
        .with_context(|| format!("Failed to write migrations file to {:?}", output_path))?;

    Ok(())
}
